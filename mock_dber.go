// Code generated by mockery v2.43.2. DO NOT EDIT.

package main

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// Mockdber is an autogenerated mock type for the dber type
type Mockdber struct {
	mock.Mock
}

type Mockdber_Expecter struct {
	mock *mock.Mock
}

func (_m *Mockdber) EXPECT() *Mockdber_Expecter {
	return &Mockdber_Expecter{mock: &_m.Mock}
}

// add provides a mock function with given fields: ctx, setlistName, artistName, songName
func (_m *Mockdber) add(ctx context.Context, setlistName string, artistName string, songName string) error {
	ret := _m.Called(ctx, setlistName, artistName, songName)

	if len(ret) == 0 {
		panic("no return value specified for add")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) error); ok {
		r0 = rf(ctx, setlistName, artistName, songName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Mockdber_add_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'add'
type Mockdber_add_Call struct {
	*mock.Call
}

// add is a helper method to define mock.On call
//   - ctx context.Context
//   - setlistName string
//   - artistName string
//   - songName string
func (_e *Mockdber_Expecter) add(ctx interface{}, setlistName interface{}, artistName interface{}, songName interface{}) *Mockdber_add_Call {
	return &Mockdber_add_Call{Call: _e.mock.On("add", ctx, setlistName, artistName, songName)}
}

func (_c *Mockdber_add_Call) Run(run func(ctx context.Context, setlistName string, artistName string, songName string)) *Mockdber_add_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *Mockdber_add_Call) Return(_a0 error) *Mockdber_add_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Mockdber_add_Call) RunAndReturn(run func(context.Context, string, string, string) error) *Mockdber_add_Call {
	_c.Call.Return(run)
	return _c
}

// clear provides a mock function with given fields: ctx, name
func (_m *Mockdber) clear(ctx context.Context, name string) error {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for clear")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Mockdber_clear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'clear'
type Mockdber_clear_Call struct {
	*mock.Call
}

// clear is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Mockdber_Expecter) clear(ctx interface{}, name interface{}) *Mockdber_clear_Call {
	return &Mockdber_clear_Call{Call: _e.mock.On("clear", ctx, name)}
}

func (_c *Mockdber_clear_Call) Run(run func(ctx context.Context, name string)) *Mockdber_clear_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Mockdber_clear_Call) Return(_a0 error) *Mockdber_clear_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Mockdber_clear_Call) RunAndReturn(run func(context.Context, string) error) *Mockdber_clear_Call {
	_c.Call.Return(run)
	return _c
}

// create provides a mock function with given fields: ctx, name
func (_m *Mockdber) create(ctx context.Context, name string) (*Setlist, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for create")
	}

	var r0 *Setlist
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*Setlist, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *Setlist); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Setlist)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Mockdber_create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'create'
type Mockdber_create_Call struct {
	*mock.Call
}

// create is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Mockdber_Expecter) create(ctx interface{}, name interface{}) *Mockdber_create_Call {
	return &Mockdber_create_Call{Call: _e.mock.On("create", ctx, name)}
}

func (_c *Mockdber_create_Call) Run(run func(ctx context.Context, name string)) *Mockdber_create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Mockdber_create_Call) Return(_a0 *Setlist, _a1 error) *Mockdber_create_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Mockdber_create_Call) RunAndReturn(run func(context.Context, string) (*Setlist, error)) *Mockdber_create_Call {
	_c.Call.Return(run)
	return _c
}

// delete provides a mock function with given fields: ctx, name
func (_m *Mockdber) delete(ctx context.Context, name string) error {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Mockdber_delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'delete'
type Mockdber_delete_Call struct {
	*mock.Call
}

// delete is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Mockdber_Expecter) delete(ctx interface{}, name interface{}) *Mockdber_delete_Call {
	return &Mockdber_delete_Call{Call: _e.mock.On("delete", ctx, name)}
}

func (_c *Mockdber_delete_Call) Run(run func(ctx context.Context, name string)) *Mockdber_delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Mockdber_delete_Call) Return(_a0 error) *Mockdber_delete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Mockdber_delete_Call) RunAndReturn(run func(context.Context, string) error) *Mockdber_delete_Call {
	_c.Call.Return(run)
	return _c
}

// find provides a mock function with given fields: ctx, name
func (_m *Mockdber) find(ctx context.Context, name string) (*Setlist, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for find")
	}

	var r0 *Setlist
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*Setlist, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *Setlist); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Setlist)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Mockdber_find_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'find'
type Mockdber_find_Call struct {
	*mock.Call
}

// find is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Mockdber_Expecter) find(ctx interface{}, name interface{}) *Mockdber_find_Call {
	return &Mockdber_find_Call{Call: _e.mock.On("find", ctx, name)}
}

func (_c *Mockdber_find_Call) Run(run func(ctx context.Context, name string)) *Mockdber_find_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Mockdber_find_Call) Return(_a0 *Setlist, _a1 error) *Mockdber_find_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Mockdber_find_Call) RunAndReturn(run func(context.Context, string) (*Setlist, error)) *Mockdber_find_Call {
	_c.Call.Return(run)
	return _c
}

// remove provides a mock function with given fields: ctx, setlistName, songName, songNumber
func (_m *Mockdber) remove(ctx context.Context, setlistName string, songName string, songNumber int) error {
	ret := _m.Called(ctx, setlistName, songName, songNumber)

	if len(ret) == 0 {
		panic("no return value specified for remove")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int) error); ok {
		r0 = rf(ctx, setlistName, songName, songNumber)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Mockdber_remove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'remove'
type Mockdber_remove_Call struct {
	*mock.Call
}

// remove is a helper method to define mock.On call
//   - ctx context.Context
//   - setlistName string
//   - songName string
//   - songNumber int
func (_e *Mockdber_Expecter) remove(ctx interface{}, setlistName interface{}, songName interface{}, songNumber interface{}) *Mockdber_remove_Call {
	return &Mockdber_remove_Call{Call: _e.mock.On("remove", ctx, setlistName, songName, songNumber)}
}

func (_c *Mockdber_remove_Call) Run(run func(ctx context.Context, setlistName string, songName string, songNumber int)) *Mockdber_remove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int))
	})
	return _c
}

func (_c *Mockdber_remove_Call) Return(_a0 error) *Mockdber_remove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Mockdber_remove_Call) RunAndReturn(run func(context.Context, string, string, int) error) *Mockdber_remove_Call {
	_c.Call.Return(run)
	return _c
}

// save provides a mock function with given fields: ctx, name
func (_m *Mockdber) save(ctx context.Context, name string) (*Setlist, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for save")
	}

	var r0 *Setlist
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*Setlist, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *Setlist); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Setlist)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Mockdber_save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'save'
type Mockdber_save_Call struct {
	*mock.Call
}

// save is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *Mockdber_Expecter) save(ctx interface{}, name interface{}) *Mockdber_save_Call {
	return &Mockdber_save_Call{Call: _e.mock.On("save", ctx, name)}
}

func (_c *Mockdber_save_Call) Run(run func(ctx context.Context, name string)) *Mockdber_save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Mockdber_save_Call) Return(_a0 *Setlist, _a1 error) *Mockdber_save_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Mockdber_save_Call) RunAndReturn(run func(context.Context, string) (*Setlist, error)) *Mockdber_save_Call {
	_c.Call.Return(run)
	return _c
}

// update provides a mock function with given fields: ctx, oldName, newName
func (_m *Mockdber) update(ctx context.Context, oldName string, newName string) (*Setlist, error) {
	ret := _m.Called(ctx, oldName, newName)

	if len(ret) == 0 {
		panic("no return value specified for update")
	}

	var r0 *Setlist
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*Setlist, error)); ok {
		return rf(ctx, oldName, newName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *Setlist); ok {
		r0 = rf(ctx, oldName, newName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Setlist)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, oldName, newName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Mockdber_update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'update'
type Mockdber_update_Call struct {
	*mock.Call
}

// update is a helper method to define mock.On call
//   - ctx context.Context
//   - oldName string
//   - newName string
func (_e *Mockdber_Expecter) update(ctx interface{}, oldName interface{}, newName interface{}) *Mockdber_update_Call {
	return &Mockdber_update_Call{Call: _e.mock.On("update", ctx, oldName, newName)}
}

func (_c *Mockdber_update_Call) Run(run func(ctx context.Context, oldName string, newName string)) *Mockdber_update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Mockdber_update_Call) Return(_a0 *Setlist, _a1 error) *Mockdber_update_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Mockdber_update_Call) RunAndReturn(run func(context.Context, string, string) (*Setlist, error)) *Mockdber_update_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockdber creates a new instance of Mockdber. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockdber(t interface {
	mock.TestingT
	Cleanup(func())
}) *Mockdber {
	mock := &Mockdber{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
